															вопросы к консе по C++

Когда (не) надо писать return std::move(foo); РЕШЕНО: в обычных ситуациях компилятор сам соптимизирует и заменит `return a` на `return std::move(a)` + если напишите как ебланы, не сработает RVO. а когда надо? когда возвращаемый именно rvalue ссылку (бробрасываем аргумент дальше)

почему gets и scanf в C - гавно??? РЕШЕНО: пишет пока пишется, не чекает длину буфера, не чекает \0

почему внутри одного макроса могут корректно вызываться другие, но рекурсивно раскрываться не может? РЕШЕНО: потому что в первом случае понятно, сколько раз нужно сделать вызов на уровень ниже, во втором эта глубина определяется на этапе исполнения (а препроцессор работает перед компиляцией)

Получение most derived class при помощи dynamic_cast: РЕШЕНО dynamic_cast<void*>() отправит максимально ВНИЗ - в тип объекта, от которого накастовались когда-то вниз

Отличия ref/cref и perfect forwarding: че за ref/cref: РЕШЕНО std::ref возвращает reference_wrapper от своего аргумента, который по факту является ссылкой (семантика совпадает), но его можно передавать как шаблонный параметр.
бывает, что функция принимает по perfetct forwarding, бывает по значению. если принимает по значению и очень хочется, чтоб приняло "по ссылке", хуярим по ref/cref

почему шаблоны нужно полностью писать в хэдерах: РЕШЕНО потому что компилятор может подставлять конкретный T в шаблон, только если он (шаблон) определен в единице трансляции, в которой нужна инстациация от этого T (либо, если нашлась инстациация с нужным T в другой единице трансляциии, то она будет использована). Причем каждый шаблон внутренне встраивается (добавляется inline неявно), поэтому при нескольких инстациациях от одного T не нарушим ODR

сериализация/десериализация - запись/чтение объекта из файла побайтово

димов-абрамс: РЕШЕНО проблема в выборе перегрузки, когда у них есть свои специализации (полные!!!). Может оказаться так, что какая-то перегрузка и специализация другой перегрузки подходят, тогда выберет ХУЙ ЗНАЕТ КАКУЮ (такого стоит избегать)

че за opaque структуры? РЕШЕНО: структуры, указатели на них - внутри них нельзя лезть

Разрешение перегрузок с шаблонными функциями и автовыводом шаблонных параметров: что из себя представляют overload_set (видимо все перегрузки, с нужным количеством аргументов) -> viable_functions (видимо подмножество специализиаций перегрузки) -> best_viable_function (самая пиздатая)

линковка C++ и C:
gcc a.c -c -o a
g++-12 b.cpp -c -o b
g++-12 a b -lstdc++ -o res
./res

auto НЕ включает в себя ссылочность!!!
decltype(auto) - в возвращаемом функцией типе. смотрит decltype от первого return в функции (с поправкой на name/expression)
                 в присваивании переменной. смотрит decltype от того, что хотим положить в переменную (уже 100% expression) и выводит нужный                                      тип с учетом ссылочности
