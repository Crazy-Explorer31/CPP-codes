# Useful git commands
* `git diff --staged` --- показывает разницу между staged и commited
* `git diff`          --- показывает разницу между unindexed и staged
* * Замечание: все diff'ы могут иметь непустой вывод
* `git reset HEAD` --- убирает всё из index, но unindexed не трогает
* `git log --oneline --graph` --- показывает коммиты, достижимые из текущей ветки
* * `git log -p` --- покажет коммиты с их изменениями
* `git diff branch_1 branch_2` --- показывает разницу веток (изменения, которые `branch_1` превращают в `branch_2`)
* `git branch -d feature` --- удаляет ветку
* `git commit --amend` --- добавляет изменения из staged в последний коммит
* `git merge feature` --- делает новый коммит, включающий новшества текущей ветки и ветки `feature` (коммит с двумя родителями)
*  * в случае merge-conflict git укажет на файлы с конфликтами
*  * в этих файлах оставляем только нужные строки (в редакторе)
*  * с этими файлами --- `add + commit`
* `git rebase feature` --- сует изменения из `feature` в узел расхождения текущей ветки и `feature` (в ~середину (базу) коммитов текущей ветки вставляются коммиты `feature`)
* * Если `git merge` из `feature`, то она догонит ту ветку, базу которой изменила (fast-forward)
* `git rebase -i HEAD~5` --- откроет окно для интерактивного изменения порядка/названия/склеивания предыдущих 5 коммитов
* `git reset --soft` --- удалит последний коммит, а его изменения переместит в index
* `git reset --mixed` --- удалит последний коммит, а его изменения перестит в unindexed
* `git reset --hard` --- удалит последний коммит, как и его изменения
* `git clean -f -d` --- очистит директорию от неотслеживаемых файлов (untracked)
* * `git clean -n -d` --- показывает, какие файлы будут почищены предыдущей командой
* `git show <hash>` --- показывает изменения коммита по хэшу
* `git stash` --- припрятать изменения в текущей ветке
* * `git stash list` --- список доступных припряченных состояний
* * `git stash apply` --- применить припрятанные изменения, запихать все в unstaged
* * `git stash apply --index 0` --- применить припрятанные изменения, распихать всё как было (staged может оказаться не пустым)
* * `git stash drop stash{0}` --- удалить припрятанное
* `.gitignore` --- файл с файлами, которые git не будет отслеживать (если они не были проиндексированы до создания `.gitignore`). Пример такого файла:
```
*.md       # такие заигнорены
!README.md # но не этот красавчик
```
* `git rm <file>` --- уберет `<file>` из репозитория (надо закоммитить). 
* * `git rm --cached <file>` --- уберет из репозитория, но не удалит из директории
* `git tag <tag_name> <commit>` --- поставит метку `<tag_name>` на коммит `<commit>`. Нужно, чтоб отмечать важные коммиты
* * `git log --oneline --tags` --- покажет лишь коммиты с тэгами
* * `git tag -d <tag_name>` --- удалит метку `<tag_name>` с соответствующего коммита
* * `git rev-parse <tag_name>` --- покажет хэш коммита с тэгом `<tag_name>`
* `git reflog` --- показывает на коммиты, на которые когда либо указывал HEAD, в том числе и на удаленные с помощью `git reset` (на них можно возвращаться с `git reset --hard` по хэшу)
* `git bisect start` --- запустит режим поиска первого коммита с багом (ситуация: последний коммит с багом, первый --- без. где-то возник первый коммит с багос. хотим его найти и revert-нуть)
* * `git bisect bad` --- помечает текущий коммит плохим
* * `git bisect good initial-commit` --- пометит коммит как хороший (после указания этих двух границ git сам начнет `checkout`-иться по коммитам, нам нужно лишь указывать `git bisect bad/good` на текущем коммите)
* * `git run './test.sh'` --- бин поиск по коммитам запустится сам. Коммит хороший, если и только если код возврата `./test.sh` равен 0

# Stuff
* `tail -n +1 *` --- показать содержимое всех файлов в директории
* `ls -R | tree` --- показать дерево достижимых из текущей директории